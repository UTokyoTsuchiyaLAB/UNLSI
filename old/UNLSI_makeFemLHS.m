function frame = UNLSI_makeFemLHS(frame,surfThn,surfE,surfRho)
nbVerts = numel(frame.usedVerts);
frame.surfThn = surfThn;
frame.surfE = surfE;
frame.surfRho = surfRho;
nu = 0.34;
qps = [1/6,1/6;2/3,1/6;1/6,2/3];
Ke = zeros(6*size(frame.usedVerts,2),6*size(frame.usedVerts,2));
frame.Fw = zeros(6*size(frame.usedVerts,2),1);
frame.stressMat = zeros(size(frame.tri,1)*3,size(frame.verts,1)*3);
frame.strainMat = zeros(size(frame.tri,1)*3,size(frame.verts,1)*3);
for iter = 1:size(frame.tri,1)
    if frame.isWake(iter,1) == 0
        frame.Wg{iter}(1,1:6) = 0;frame.Wg{iter}(1,3) = -frame.g0.*frame.surfRho(iter,1).*frame.area(iter,1).*frame.surfThn(iter,1)./3;
        frame.Wg{iter}(2,1:6) = 0;frame.Wg{iter}(2,3) = -frame.g0.*frame.surfRho(iter,1).*frame.area(iter,1).*frame.surfThn(iter,1)./3;
        frame.Wg{iter}(3,1:6) = 0;frame.Wg{iter}(3,3) = -frame.g0.*frame.surfRho(iter,1).*frame.area(iter,1).*frame.surfThn(iter,1)./3;
        frame.Fw(frame.IndexRow{iter}(:,1),1) = frame.Fw(frame.IndexRow{iter}(:,1),1)+frame.Wg{iter}(:);
        Dp(1,1) = 1.0; Dp(1,2) = nu;
        Dp(2,1) = nu;  Dp(2,2) = 1.0;
        Dp(3,3) = (1.0-nu)/2.0;
        Dm = Dp;
        Dm = Dm.*surfE(iter,1)/(1.0-nu*nu);
        Dp = Dp.*(surfE(iter,1)*surfThn(iter,1)^3/(12.0*(1.0-nu*nu)));
        U = frame.verts(frame.tri(iter,2),:)-frame.verts(frame.tri(iter,1),:);
        V = frame.verts(frame.tri(iter,3),:)-frame.verts(frame.tri(iter,1),:);
        transUV(:,1) = U;
        transUV(:,2) = V;
        W = cross(U,V);
        trafo(1,:) = U./norm(U);
        trafo(3,:) = W./norm(W);
        trafo(2,:) = cross(trafo(3,:),trafo(1,:));
        transUV = trafo*transUV;
        dphi(1,1) = -transUV(1,1); % x12 = x1-x2 = 0-x2 = -x2
        dphi(2,1) =  transUV(1,2); % x31 = x3-x1 = x3-0 = x3
        dphi(3,1) =  transUV(1,1)-transUV(1,2); % x23 = x2-x3
        dphi(1,2) = -transUV(2,1); % y12 = y1-y2 = -y2 = 0 (stays zero, as node B and A lie on local x-axis and therefore)
        dphi(2,2) =  transUV(2,2); % y31 = y3-y1 = y3-0 = y3
        dphi(3,2) =  transUV(2,1)-transUV(2,2); % y23 = y2-y3 = 0-y3 = -y3
        B_m(1,1) =  dphi(3,2); %  y23
        B_m(1,3) =  dphi(2,2); %  y31
        B_m(1,5) =  dphi(1,2); %  y12
        B_m(2,2) = -dphi(3,1); % -x23
        B_m(2,4) = -dphi(2,1); % -x31
        B_m(2,6) = -dphi(1,1); % -x12
        B_m(3,1) = -dphi(3,1); % -x23
        B_m(3,2) =  dphi(3,2); %  y23
        B_m(3,3) = -dphi(2,1); % -x31
        B_m(3,4) =  dphi(2,2); %  y31
        B_m(3,5) = -dphi(1,1); % -x12
        B_m(3,6) =  dphi(1,2); %  y12
        B_m = B_m.*1.0/(2.0*(frame.area(iter,1)));
        %frame.B_m{iter} = B_m;
        Ke_m{iter} = B_m'*Dm*B_m.*surfThn(iter,1)*frame.area(iter,1);
        
        sidelen(1) = dphi(1,1)^2+dphi(1,2)^2;
        sidelen(2) = dphi(2,1)^2+dphi(2,2)^2;
        sidelen(3) = dphi(3,1)^2+dphi(3,2)^2;
        Y(1,1) = dphi(3,2)^2.0;
        Y(1,2) = dphi(2,2)^2.0;
        Y(1,3) = dphi(3,2)*dphi(2,2);
        Y(2,1) = dphi(3,1)^2.0;
        Y(2,2) = dphi(2,1)^2.0;
        Y(2,3) = dphi(2,1)*dphi(3,1);
        Y(3,1) = -2.0*dphi(3,1)*dphi(3,2);
        Y(3,2) = -2.0*dphi(2,1)*dphi(2,1);
        Y(3,3) = -dphi(3,1)*dphi(2,2)-dphi(2,1)*dphi(3,2);
        Y = Y.* 1.0/(4.0*frame.area(iter,1)^2.0);
        Ke_p{iter} = zeros(9,9);
        for j = 1:3
            B = evalBTri(sidelen, qps(j,1), qps(j,2), dphi);
            temp = B'*Y'*Dp*Y*B./6;
            Ke_p{iter} = Ke_p{iter}+temp;
        end
        Ke_p{iter} = Ke_p{iter}.*2.*frame.area(iter,1);
        
        K_out = zeros(18,18);
        for i=0:2
            for j = 0:2 
                K_out(  6*i+1,    6*j+1)   = Ke_m{iter}(2*i+1,  2*j+1);   % uu
                K_out(  6*i+1,    6*j+1+1) = Ke_m{iter}(2*i+1,  2*j+1+1); % uv
                K_out(  6*i+1+1,  6*j+1)   = Ke_m{iter}(2*i+1+1,2*j+1);   % vu
                K_out(  6*i+1+1,  6*j+1+1) = Ke_m{iter}(2*i+1+1,2*j+1+1); % vv
                K_out(2+6*i+1,  2+6*j+1)   = Ke_p{iter}(3*i+1,  3*j+1);   % ww
                K_out(2+6*i+1,  2+6*j+1+1) = Ke_p{iter}(3*i+1,  3*j+1+1); % wx
                K_out(2+6*i+1,  2+6*j+2+1) = Ke_p{iter}(3*i+1,  3*j+2+1); % wy
                K_out(2+6*i+1+1,2+6*j+1)   = Ke_p{iter}(3*i+1+1,3*j+1);   % xw
                K_out(2+6*i+1+1,2+6*j+1+1) = Ke_p{iter}(3*i+1+1,3*j+1+1); % xx
                K_out(2+6*i+1+1,2+6*j+2+1) = Ke_p{iter}(3*i+1+1,3*j+2+1); % xy
                K_out(2+6*i+2+1,2+6*j+1)   = Ke_p{iter}(3*i+2+1,3*j+1);   % yw
                K_out(2+6*i+2+1,2+6*j+1+1) = Ke_p{iter}(3*i+2+1,3*j+1+1); % yx
                K_out(2+6*i+2+1,2+6*j+2+1) = Ke_p{iter}(3*i+2+1,3*j+2+1); % yy
            end
        end
        TSub = [trafo,zeros(3,3);zeros(3,3),trafo];
        KeSub = zeros(6,6);
        KeNew = zeros(18,18);
        Kl = K_out;
        Kg = zeros(18,18);
        for i=0:2
            for j = 0:2
                % copy values into temporary sub-matrix for correct format to transformation
                for k=0:5
                    for l=0:5
                        KeSub(k+1,l+1) = K_out(i*6+k+1,j*6+l+1);
                    end
                end
                % the actual transformation step
                KeSub=TSub'*KeSub*TSub;
                % copy transformed values into new global stiffness matrix
                for k=0:5
                    for l=0:5
                        KeNew(i*6+k+1,j*6+l+1) = KeSub(k+1,l+1);
                    end
                end
            end
        end

        for alpha = 0:5
            for beta=0:5
                for i=0:2
                    for j=0:2
                        Kg(3*alpha+i+1,3*beta+j+1) = KeNew(6*i+alpha+1,6*j+beta+1);
                    end  
                end
            end
        end
        %Kg{iter} = Kg;
        %Kl{iter} = Kl;
    end
    if frame.isWake(iter,1) == 0
        for i = 1:size(frame.IndexRow{iter}(:),1)
            Ke(frame.IndexRow{iter}(i),frame.IndexCol{iter}(i)) = Ke(frame.IndexRow{iter}(i),frame.IndexCol{iter}(i))+Kg(i);
        end
        ze = zeros(1,size(frame.verts,1));
        imat = ze;
        imat(:,frame.tri(iter,1)) = 1;
        assy1 = blkdiag(imat,imat,imat);
        imat = ze;
        imat(:,frame.tri(iter,2)) = 1;
        assy2 = blkdiag(imat,imat,imat);
        imat = ze;
        imat(:,frame.tri(iter,3)) = 1;
        assy3 = blkdiag(imat,imat,imat);
        frame.stressMat(3*(iter-1)+1:3*iter,:) = Dm*(B_m*blkdiag(TSub(1:2,1:3),TSub(1:2,1:3),TSub(1:2,1:3))*[assy1;assy2;assy3]);
        frame.strainMat(3*(iter-1)+1:3*iter,:) =    B_m*blkdiag(TSub(1:2,1:3),TSub(1:2,1:3),TSub(1:2,1:3))*[assy1;assy2;assy3];
    end
end
frame.femLHS = Ke;
frame.femLHS(frame.MatIndex==0,:)=[];
frame.femLHS(:,frame.MatIndex==0)=[];
frame.invFemLHS = pinv(frame.femLHS);
frame.femRHSw = frame.Fw(frame.MatIndex==1,1);
delta_w = frame.invFemLHS*frame.femRHSw;
disp_buff(frame.InvMatIndex,1)=delta_w;
frame.delta_SelfWeight = zeros(size(frame.verts));
frame.delta_SelfWeight(frame.usedVerts,1)=disp_buff(1:nbVerts,1);
frame.delta_SelfWeight(frame.usedVerts,2)=disp_buff(nbVerts+1:2*nbVerts,1);
frame.delta_SelfWeight(frame.usedVerts,3)=disp_buff(2*nbVerts+1:3*nbVerts,1);
end

function out = evalBTri(C,L1,L2,dphi)

    mu1 = (C(1)-C(2))/C(3);
    mu2 = (C(3)-C(1))/C(2);
    mu3 = (C(2)-C(3))/C(1);

	% some abbreviations to shorten the following terms
    L3 = 1-L1-L2;
    f13mu1 = 1+3*mu1;
    f13mu2 = 1+3*mu2;
    f13mu3 = 1+3*mu3;
    f1m3mu3 = 1-3*mu3;
    fm13mu2 = -1+3*mu2;
    fm1m3mu3 = -1-3*mu3;
    f1mmu1 = 1-mu1;
    f1mmu2 = 1-mu2;
    f1mmu3 = 1-mu3;

    a = 3*f1mmu3*L1-f13mu3*L2+f13mu3*L3;
    b = 3*f1mmu2*L3-f13mu2*L1+f13mu2*L2;
    c = 3*f1mmu1*L2-f13mu1*L3+f13mu1*L1;

	% see page 38f of the thesis:
	% the following terms contains second order derivatives of the 9 shape functions
	% wrt the triangle coordinates L1 and L2
    out(1,1) = 6 + L2*(-4-2*a) + 4*f1m3mu3*(L2*L3-L1*L2) - 12*L1 + 2*L2*b + 8*(L2*L3-L1*L2);

    out(1,2) = -dphi(2,2)*(-2+6*L1+4*L2-L2*b-4*L2*L3+4*L1*L2) ...
               -dphi(1,2)*(2*L2-L2*a+L2*L3*2*f1m3mu3-L1*L2*2*f1m3mu3);

    out(1,3) =  dphi(2,1)*(-2+6*L1+4*L2-L2*b-4*L2*L3+4*L1*L2) ...
               +dphi(1,1)*(2*L2-L2*a+L2*L3*2*f1m3mu3-L1*L2*2*f1m3mu3);

    out(1,4) = -2*L2*c + 4*f13mu1*(L2*L3-L1*L2) - 4*L2 + 2*L2*a + 4*f1m3mu3*(-L2*L3+L1*L2);

    out(1,5) = -dphi(1,2)*(2*L2-L2*a+L2*L3*2*f1m3mu3-L1*L2*2*f1m3mu3) ...
               -dphi(3,2)*(-L2*c+L2*L3*2*f13mu1-L1*L2*2*f13mu1);

    out(1,6) = dphi(1,1)*(2*L2-L2*a+L2*L3*2*f1m3mu3-L1*L2*2*f1m3mu3) ...
              +dphi(3,1)*(-L2*c+L2*L3*2*f13mu1-L1*L2*2*f13mu1);

    out(1,7) = -6 + 12*L1 + 8*L2 - 2*L2*b + 8*(L1*L2-L2*L3) + 2*L2*c + 4*f13mu1*(L1*L2-L2*L3);

    out(1,8) = -dphi(3,2)*(-L2*c+L2*L3*2*f13mu1-L1*L2*2*f13mu1) ...
               -dphi(2,2)*(-4+6*L1+4*L2-L2*b-4*L2*L3+4*L1*L2);

    out(1,9) = dphi(3,1)*(-L2*c+L2*L3*2*f13mu1-L1*L2*2*f13mu1) ...
              +dphi(2,1)*(-4+6*L1+4*L2-L2*b-4*L2*L3+4*L1*L2);

    out(2,1) = -2*L1*a + 2*L1*L3*2*fm1m3mu3 - 2*L1*L2*2*fm1m3mu3 - 4*L1+2*L1*b - 2*L1*L3*2*fm13mu2 + 2*L1*L2*2*fm13mu2;

    out(2,2) = -dphi(2,2)*(2*L1-1*L1*b+1*L1*L3*2*fm13mu2-1*L1*L2*2*fm13mu2) ...
               -dphi(1,2)*(-1*L1*a+1*L1*L3*2*fm1m3mu3-1*L1*L2*2*fm1m3mu3);

    out(2,3) = dphi(2,1)*(2*L1-1*L1*b+1*L1*L3*2*fm13mu2-1*L1*L2*2*fm13mu2) ...
              +dphi(1,1)*(-1*L1*a+1*L1*L3*2*fm1m3mu3-1*L1*L2*2*fm1m3mu3);

    out(2,4) = 6 - 12*L2 - 4*L1-2*L1*c + 8*L3*L1 - 8*L1*L2 + 2*L1*a - 2*L1*L3*2*fm1m3mu3 + 2*L1*L2*2*fm1m3mu3;

    out(2,5) = -dphi(1,2)*(-1*L1*a+1*L1*L3*2*fm1m3mu3-1*L1*L2*2*fm1m3mu3) ...
               -dphi(3,2)*(-6*L2+2-2*L1-1*L1*c+4*L3*L1-4*L1*L2);

    out(2,6) = dphi(1,1)*(-1*L1*a+1*L1*L3*2*fm1m3mu3-1*L1*L2*2*fm1m3mu3) ...
              +dphi(3,1)*(-6*L2+2-2*L1-1*L1*c+4*L3*L1-4*L1*L2);

    out(2,7) = -6 + 8*L1 - 2*L1*b + 2*L1*L3*2*fm13mu2 - 2*L1*L2*2*fm13mu2 + 12*L2 + 2*L1*c - 8*L3*L1 +  8*L1*L2;

    out(2,8) = -dphi(3,2)*(-6*L2+4-2*L1-1*L1*c+4*L3*L1-4*L1*L2) ...
               -dphi(2,2)*(2*L1-1*L1*b+1*L1*L3*2*fm13mu2-1*L1*L2*2*fm13mu2);

    out(2,9) = dphi(3,1)*(-6*L2+4-2*L1-1*L1*c+4*L3*L1-4*L1*L2) ...
              +dphi(2,1)*(2*L1-1*L1*b+1*L1*L3*2*fm13mu2-1*L1*L2*2*fm13mu2);

    out(3,1) = 2 - 4*L1 + L3*a - L2*a + L2*L3*2*fm1m3mu3 - L1*a - L1*L2*2*fm1m3mu3 + L1*L3*2*f1m3mu3 - L1*L2*2*f1m3mu3 ...
                 - 4*L2 - L3*b + L2*b - L2*L3*2*fm13mu2  + L1*b + L1*L2*2*fm13mu2  + 4*L3*L1         - 4*L1*L2;

    out(3,2) = -dphi(2,2)*(-1 + 4*L1 + 2*L2 + 0.5*L3*b - 0.5*L2*b + 0.5*L2*L3*2*fm13mu2 ...
                             - 0.5*L1*b - 0.5*L1*L2*2*fm13mu2 - 2*L3*L1 + 2*L1*L2) ...
               -dphi(1,2)*(2*L1 + 0.5*L3*a - 0.5*L2*a + 0.5*L2*L3*2*fm1m3mu3 - 0.5*L1*a ...
                             - 0.5*L1*L2*2*fm1m3mu3 + 0.5*L1*L3*2*f1m3mu3 - 0.5*L1*L2*2*f1m3mu3);

    out(3,3) =  dphi(2,1)*(-1 + 4*L1 + 2*L2 + 0.5*L3*b - 0.5*L2*b + 0.5*L2*L3*2*fm13mu2 ...
                             - 0.5*L1*b - 0.5*L1*L2*2*fm13mu2 - 2*L3*L1 + 2*L1*L2) ...
               +dphi(1,1)*(2*L1 + 0.5*L3*a - 0.5*L2*a + 0.5*L2*L3*2*fm1m3mu3 - 0.5*L1*a ...
                             - 0.5*L1*L2*2*fm1m3mu3 + 0.5*L1*L3*2*f1m3mu3 - 0.5*L1*L2*2*f1m3mu3);

    out(3,4) = 2 - 4*L2 + L3*c - L2*c + 4*L2*L3 - L1*c - 4*L1*L2 + L1*L3*2*f13mu1 - L1*L2*2*f13mu1 ...
                 - 4*L1 - L3*a + L2*a + L1*a - L2*L3*2*fm1m3mu3 + L1*L2*2*fm1m3mu3 - L1*L3*2*f1m3mu3 ...
                 + L1*L2*2*f1m3mu3;

    out(3,5) = -dphi(1,2)*(2*L1 ...
                   +0.5*L3*a ...
                   -0.5*L2*a ...
                   +0.5*L2*L3*2*fm1m3mu3 ...
                   -0.5*L1*a ...
                   -0.5*L1*L2*2*fm1m3mu3 ...
                   +0.5*L1*L3*2*f1m3mu3 ...
                   -0.5*L1*L2*2*f1m3mu3 ...
                   -1) ...
             -dphi(3,2)*(-2*L2 ...
                   +0.5*L3*c ...
                   -0.5*L2*c ...
                   +2*L2*L3 ...
                   -0.5*L1*c ...
                   -2*L1*L2 ...
                   +0.5*L1*L3*2*f13mu1 ...
                   -0.5*L1*L2*2*f13mu1 ...
                   );

    out(3,6) = dphi(1,1)*(2*L1 ...
                  +0.5*L3*a ...
                  -0.5*L2*a ...
                  +0.5*L2*L3*2*fm1m3mu3 ...
                  -0.5*L1*a ...
                  -0.5*L1*L2*2*fm1m3mu3 ...
                  +0.5*L1*L3*2*f1m3mu3 ...
                  -0.5*L1*L2*2*f1m3mu3 ...
                  -1) ...
             +dphi(3,1)*(-2*L2 ...
                   +0.5*L3*c ...
                   -0.5*L2*c ...
                   +2*L2*L3 ...
                   -0.5*L1*c ...
                   -2*L1*L2 ...
                   +0.5*L1*L3*2*f13mu1 ...
                   -0.5*L1*L2*2*f13mu1 ...
                   );

    out(3,7) = -4 ...
             +8*L1 ...
             +8*L2 ...
             +L3*b ...
             -L2*b ...
             +L2*L3*2*fm13mu2 ...
             -L1*b ...
             -L1*L2*2*fm13mu2 ...
             -4*L3*L1 ...
             +8*L1*L2 ...
             -L3*c ...
             +L2*c ...
             -4*L2*L3 ...
             +L1*c ...
             -L1*L3*2*f13mu1 ...
             +L1*L2*2*f13mu1;

    out(3,8) = -dphi(3,2)*(-2*L2 ...
                   +0.5*L3*c ...
                   -0.5*L2*c ...
                   +2*L2*L3 ...
                   -0.5*L1*c ...
                   -2*L1*L2 ...
                   +0.5*L1*L3*2*f13mu1 ...
                   -0.5*L1*L2*2*f13mu1 ...
                   +1) ...
             -dphi(2,2)*(-2  ...
                   +4*L1 ...
                   +2*L2 ...
                   +0.5*L3*b ...
                   -0.5*L2*b ...
                   +0.5*L2*L3*2*fm13mu2 ...
                   -0.5*L1*b ...
                   -0.5*L1*L2*2*fm13mu2 ...
                   -2*L3*L1 ...
                   +2*L1*L2 ...
                   );

    out(3,9) = dphi(3,1)*(-2*L2  ...
                  +0.5*L3*c ...
                  -0.5*L2*c ...
                  +2*L2*L3 ...
                  -0.5*L1*c ...
                  -2*L1*L2 ...
                  +0.5*L1*L3*2*f13mu1 ...
                  -0.5*L1*L2*2*f13mu1 ...
                  +1 ...
                  ) ...
            +dphi(2,1)*(-2 ...
                  +4*L1 ...
                  +2*L2 ...
                  +0.5*L3*b ...
                  -0.5*L2*b ...
                  +0.5*L2*L3*2*fm13mu2 ...
                  -0.5*L1*b ...
                  -0.5*L1*L2*2*fm13mu2 ...
                  -2*L3*L1 ...
                  +2*L1*L2 ...
                 );
	% the last row of the matrix must be multipled by 2 (this way, the upper terms gets a bit shorter ...)
    for i=1:9
        out(3,i) = out(3,i)*2.0;
    end

end