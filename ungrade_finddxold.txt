                tempTR = obj.optimization.TR;
                while(1)
                    if exitflag < 0
                        [dxscaled,fval,exitflagdx,~,lambda] = fmincon(@(x)obj.fminconObj(x,obj.optimization.H,objTotalGrad),zeros(numel(obj.designVariables),1),alin,blin,[],[],lbf,ubf,@(x)obj.fminconNlc(x,tempTR),options);
                        [dxscaledc,fvalc,exitflagdxc,~,lambdac] = fmincon(@(x)obj.fminconObj(x,obj.optimization.H,objTotalGrad),zeros(numel(obj.designVariables),1),alin,blin,[],[],lbf,ubf,@(x)obj.fminconNlc2(x,tempTR,obj.optimization.H,dxscaled),options);
                    else
                        [dxscaled,fval,exitflagdx] = fmincon(@(x)obj.fminconObj(x,obj.optimization.H,objTotalGrad),zeros(numel(obj.designVariables),1),alin,blin,[],[],lbf,ubf,@(x)obj.fminconNlc(x,tempTR),options);
                        [dxscaledc,fvalc,exitflagdxc] = fmincon(@(x)obj.fminconObj(x,obj.optimization.H,objTotalGrad),zeros(numel(obj.designVariables),1),alin,blin,[],[],lbf,ubf,@(x)obj.fminconNlc2(x,tempTR,obj.optimization.H,dxscaled),options);
                    end
                    rho = 1000;
                    if not(isempty(con0))
                        lambdaR = -(dR_du)\(dI_du+lambda.ineqlin'*[-dcon_du;dcon_du])';
                        Lorg = I0 + lambda.ineqlin'*[-con0;con0];
                        penaltyorg = rho*sum(max(max(0,cmin-con0),max(con0-cmax)));
                        dL_dx = dI_dx+lambdaR'*dR_dx+lambda.ineqlin'*[-dcon_dx;dcon_dx];
                    else
                        lambdaR = -(dR_du)\(dI_du)';
                        Lorg = I0 ;
                        penaltyorg = 0;
                        dL_dx = dI_dx+lambdaR'*dR_dx;
                    end
                    obj.optimization.LagrangianVal(obj.iteration) = Lorg;
                    obj.optimization.penaltyVal(obj.iteration) = Lorg;

                    dx = dxscaled(:)'.*obj.designScale;
                    dxc = dxscaledc(:)'.*obj.designScale;
                    
                    %精度評価
                    desdx = obj.designVariables.*obj.designScale+obj.lb+dx(:)';
                    [modSurfdx,~,SREFdx,BREFdx,CREFdx,XYZREFdx,argin_xdx,desdx] = obj.surfGenFun(desdx);
                    modMeshdx = obj.meshDeformation(modSurfdx);
                    objdx = obj.setVerts(modMeshdx);
                    if any(obj.flowNoList(:,3) == 1)
                        objdx = objdx.makeEquation(obj.unlsiParam.wakeLength,obj.unlsiParam.n_wake,obj.unlsiParam.n_divide);
                    end
                    objdx = objdx.setREFS(SREFdx,BREFdx,CREFdx);
                    objdx = objdx.setRotationCenter(XYZREFdx);
                    for iter = 1:numel(obj.flow)
                        alphabuff = obj.unlsiParam.alpha(obj.flowNoList(:,2)==obj.flow{iter}.Mach);
                        betabuff = obj.unlsiParam.beta(obj.flowNoList(:,2)==obj.flow{iter}.Mach);
                        [udx,~] = objdx.solvePertPotential(iter,alphabuff,betabuff);%ポテンシャルを求める
                        [AERODATA,Cp,Cfe,Rdx,objdx] = objdx.solveFlowForAdjoint(udx,iter,alphabuff,betabuff);%ポテンシャルから空力係数を計算
                    end
                   
                    [Idx,condx] = objandConsFun(desdx,AERODATA,Cp,Cfe,SREFdx,BREFdx,CREFdx,XYZREFdx,argin_xdx);
                    if not(isempty(con0))
                        Ldx = Idx + lambda.ineqlin'*[-condx;condx];
                        if penaltyorg < sqrt(eps)
                            penaltydx = 0;
                        else
                           penaltydx = rho*sum(max(max(0,cmin-condx),max(condx-cmax))); 
                        end
                    else
                        Ldx = Idx ;
                        penaltydx = 0;
                    end

                    %共役勾配精度評価
                    desdxc = obj.designVariables.*obj.designScale+obj.lb+dxc(:)';
                    [modSurfdxc,~,SREFdxc,BREFdxc,CREFdxc,XYZREFdxc,argin_xdxc,desdxc] = obj.surfGenFun(desdxc);
                    modMeshdxc = obj.meshDeformation(modSurfdxc);
                    objdxc = obj.setVerts(modMeshdxc);
                    if any(obj.flowNoList(:,3) == 1)
                        objdxc = objdxc.makeEquation(obj.unlsiParam.wakeLength,obj.unlsiParam.n_wake,obj.unlsiParam.n_divide);
                    end
                    objdxc = objdxc.setREFS(SREFdxc,BREFdxc,CREFdxc);
                    objdxc = objdxc.setRotationCenter(XYZREFdxc);
                    for iter = 1:numel(obj.flow)
                        alphabuff = obj.unlsiParam.alpha(obj.flowNoList(:,2)==obj.flow{iter}.Mach);
                        betabuff = obj.unlsiParam.beta(obj.flowNoList(:,2)==obj.flow{iter}.Mach);
                        [udxc,~] = objdxc.solvePertPotential(iter,alphabuff,betabuff);%ポテンシャルを求める
                        [AERODATA,Cp,Cfe,Rdxc,objdxc] = objdxc.solveFlowForAdjoint(udxc,iter,alphabuff,betabuff);%ポテンシャルから空力係数を計算
                    end
                   
                    [Idxc,condxc] = objandConsFun(desdxc,AERODATA,Cp,Cfe,SREFdxc,BREFdxc,CREFdxc,XYZREFdxc,argin_xdxc);
                    if not(isempty(con0))
                        Ldxc = Idxc + lambda.ineqlin'*[-condxc;condxc];
                        if penaltyorg < sqrt(eps)
                            penaltydxc = 0;
                        else
                           penaltydxc = rho*sum(max(max(0,cmin-condxc),max(condxc-cmax))); 
                        end
                    else
                        Ldxc = Idxc ;
                        penaltydxc = 0;
                    end
                    
                    if penaltydxc <= penaltydx && Ldxc < Ldx
                        desdx = desdxc;
                        Ldx = Ldxc;
                        dxscaled = dxscaledc;
                        fval = fvalc;
                        Idx = Idxc;
                        condx = condxc;
                    end

                 
                    if not(isempty(con0))
                        acc = (Ldx-Lorg)/(fval+(lambda.ineqlin'*[-dcon_dx;dcon_dx])*dxscaled(:));
                    else
                        acc = (Ldx-Lorg)/(fval);
                    end
                    obj.optimization.LpredictVal(obj.iteration) = Ldx;
                    obj.optimization.trAccuracyVal(obj.iteration) = acc;
                    obj.optimization.dxNormVal(obj.iteration) = norm(dxscaled);
                    fprintf("Variables:\n")
                    disp(desOrg);
                    fprintf("------>\n")
                    disp(desdx);
                    fprintf("Objective and Constraints:\n")
                    disp([I0,con0(:)']);
                    fprintf("------>\n");
                    disp([Idx,condx(:)']);
                    fprintf("dx norm :%f\nLagrangian Value : %f -> %f\nPenalty Value : %f -> %f\nHessian Approximation Accuracy:%f\n",norm(dxscaled),Lorg,Ldx,penaltyorg,penaltydx,acc);
                    if tempTR <= obj.optimization.TRmin
                        fprintf("\n-----------Acceptable-----------\n\n");
                        break;
                    end
                    if Ldx <= Lorg && penaltydx <= penaltyorg && Ldx+penaltydx <= Lorg+penaltyorg
                        fprintf("\n-----------Accepted-----------\n\n");
                        break;
                    end
                    fprintf("\n-----------Rejected-----------\n\n")
                    if norm(dxscaled)<tempTR
                        tempTR = norm(dxscaled) * 0.9;
                    else
                        tempTR = tempTR * 0.9;
                    end
                    if exitflagdx < 0
                        tempTR = obj.optimization.TRmin;
                    end
                end
                dx = desdx-desOrg;
                if strcmpi(HessianUpdateMethod,"SR1")
                    obj.optimization.updateFunction = @obj.SR1;
                elseif strcmpi(HessianUpdateMethod,"SSR1")
                    obj.optimization.updateFunction = @obj.SSR1;
                elseif strcmpi(HessianUpdateMethod,"BFGS")
                    obj.optimization.updateFunction = @obj.BFGS;
                elseif strcmpi(HessianUpdateMethod,"DFP")
                    obj.optimization.updateFunction = @obj.DFP;
                elseif strcmpi(HessianUpdateMethod,"Broyden")
                    obj.optimization.updateFunction = @obj.Broyden;
                elseif strcmpi(HessianUpdateMethod,"MBFGS")
                    obj.optimization.updateFunction = @obj.MBFGS;
                elseif strcmpi(HessianUpdateMethod,"DBFGS")
                    obj.optimization.updateFunction = @obj.DBFGS;
                elseif strcmpi(HessianUpdateMethod,"SR1_BFGS")
                    obj.optimization.updateFunction = @(s,y,H)obj.SR1_BFGS(obj,s,y,H);
                elseif strcmpi(HessianUpdateMethod,"SSR1_MBFGS")
                    obj.optimization.updateFunction = @(s,y,H)obj.SSR1_MBFGS(obj,s,y,H);
                elseif strcmpi(HessianUpdateMethod,"BB")
                    obj.optimization.updateFunction = @obj.Barzilai_Borwein;
                end
                obj.optimization.TR = tempTR;
                if acc < 0.15
                    obj.optimization.TR = obj.optimization.TR * 0.9;
                elseif acc > 0.5
                    obj.optimization.TR = obj.optimization.TR / 0.9;
                end
                if obj.optimization.TR > obj.optimization.TRmax
                    obj.optimization.TR = obj.optimization.TRmax;
                elseif obj.optimization.TR < obj.optimization.TRmin
                    obj.optimization.TR = obj.optimization.TRmin;
                end

                %Hessianの更新
                obj.optimization.xScaled = [obj.optimization.xScaled;obj.designVariables];
                obj.optimization.dL_dx = [obj.optimization.dL_dx;dL_dx];
                if size(obj.optimization.xScaled,1) > 1
                    n_iter = size(obj.optimization.xScaled,1)-1;
                    if n_iter > nMemory
                        n_iter = nMemory;
                    end
                    if strcmpi(HessianUpdateMethod,'BB')
                        obj.optimization.stabbbScaling = 0;
                        n_iter = 1;
                    end
                    obj.optimization.H = obj.optimization.H0;
                    if obj.optimization.stabbbScaling == 1
                        s = obj.optimization.xScaled(end,:)-obj.optimization.xScaled(end-1,:);
                        y = obj.optimization.dL_dx(end,:)-obj.optimization.dL_dx(end-1,:);
                        if norm(s)>sqrt(eps) && norm(y)>sqrt(eps)
                            obj.optimization.H = obj.Barzilai_Borwein(s,y,obj.optimization.H);
                        end
                    end
                    for i = n_iter:-1:1
                        s = obj.optimization.xScaled(end-(i-1),:)-obj.optimization.xScaled(end-i,:);
                        y = obj.optimization.dL_dx(end-(i-1),:)-obj.optimization.dL_dx(end-i,:);
                        if norm(s)>sqrt(eps) && norm(y)>sqrt(eps)
                            obj.optimization.H = obj.optimization.updateFunction(s,y,obj.optimization.H);
                        end
                    end
                end